<!DOCTYPE html>
<html>
<head>
<title>Control 2.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="control-2">Control 2</h1>
<h2 id="sistemas-operativos-oto%C3%B1o-2022">Sistemas Operativos Otoño 2022</h2>
<h3 id="p1">P1</h3>
<p>Usted cuenta con un programa que corre en un multiprocesador con 8 cores siempre. En el computador, no existe un sistema operativo avanzado, por lo tanto no existen herramientas de sincronización mas avanzadas que los <em>spin-locks</em> y no posee kernel del sistema operativo. El programa utiliza siempre 4 cores que se dedicas a producir items y depositarlos en un <em>buffer</em> con el procedimiento <strong>put</strong> y 4 cores que extraen los items del <em>buffer</em> para consumirlos con el metodo <strong>get</strong>. El <em>buffer</em> solo puede almacenar 20 elementos. Se le solicita a usted programar una version correcta de <strong>put</strong> y <strong>get</strong> usando <em>spin-locks</em>. Como no existe un kernel, no hay scheduler de procesos y no hay herramientas de sincronización avanzadas.</p>
<p>Como ayuda, una solución que utiliza herramientas de sincronización como los semáforos sería de este estilo <strong>si solo considera 1 productor y 1 consumidor</strong>:</p>
<pre class="hljs"><code><div>int ult=0, prim=0;
Item buf[20];
nSem vacios /* =nMakeSem(20); */, llenos /*=nMakeSem(0);*/
void put(Item it){
    nWaitSem(vacios);
    buf[ult] =it;
    ult= (ult+1)%20;
    nSignalSem(llenos);
}
Item get(){
    Item it;
    nWaitSem(llenos);
    it = buf[prim];
    prim= (prim+1)%20;
    nsignalSem(vacios);
    return it;
}
</div></code></pre>
<p>Asuma que los valores dados son fijos y no varian (numero de cores, tamaño del buffer, tamaño de consumidores y de productores)</p>
<h3 id="p2">P2</h3>
<p>Para hacer nSystem aun mas simple, se deciden eliminar todas las herramientas de sincronización presentes. En su reemplazo se le solicta a ud que implemente como herramienta de sincronizacion la siguiente llamada:</p>
<p><code> int nExchange(nTask task, int val);</code></p>
<p>Esta llamada sirve para que dos tareas intercambien un valor entero. Para ello las dos tareas deben invocar este procedimiento pasando como argumento el identificador de la tarea con quien realizaran el intercambio (<code>task</code>) y el valor que desean intercambiar (<code>val</code>).</p>
<p>Para realizar el intercambio de valores, ambas tareas deben llamar a <code>nExchange</code> con sus respectivos descriptores. Un ejemplo de uso es el siguiente:</p>
<p>Una tarea T1 llama a <code>nExchange</code> para intercambiar informacion con T2. T1 se bloqueará hasta que T2 llame a <code>nExchange</code> con T1 como parametro. T2 puede llamar a <code>nExchange</code> con cualquier otra tarea sin necesidad de responder a la petición de T1. T2 no sabe que T1 lo está esperando y T1 al no ser parametro de <code>nExchange</code> debe seguir esperando a T2.</p>
<p>Implemente <code>nExchange</code> usando los procedimiento internos que usa nSystem para implementar herramientas de sincronizacion. Si lo necesita puede realizar cambios al descriptor de proceso, agregar nuevos estados, etc.</p>
<p>Todos los procedimientos de nSystem que deberia utilizar (se puede realizar con menos) son:</p>
<pre class="hljs"><code><div>typedef struct Task{
    int status;
    int rc;
    ...
} *nTask

Queue ready_queue;
nTask current_task;
void START_CRITICAL();
void END_CRITICAL();
void PutTask(Queue queue, nTask task);
void PushTask(Queue queue, nTask task);
nTask GetTask(Queue queue);
int EmptyQueue(Queue queue);
Queue MakeQueue();
void Resume();
</div></code></pre>
<h3 id="bonus">Bonus</h3>
<p>En Unix la operación <code>read</code> permite leer un archivo. Un sistema operativo que utiliza esta llamada, debe realizar una validación sobre el puntero que recibe para leer los datos. Desde un punto de vista de seguridad del núcleo: Que tipo de validación necesita realizar el nucleo? Cómo un usuario podria llegar a ejecutar código malicioso si esta validación no se realiza?</p>

</body>
</html>
